Game Link: https://minesweeper-one-gules.vercel.app/

## What is this? 

This is a Minesweeper clone with an added twist: it is also a solver! The solving agent uses the current state of the board to determine the probability that each cell in the board is a mine. Equipped with this information, the agent will determine the cell with the smallest probability of being a mine, ideally 0%, and will click that cell; this pattern will continue until the board has been solved or the agent loses. 

## Why Did I Create This? 

I love Minesweeper. I've been playing since I was introduced to it in 10th grade, and I've probably invested ~1000 hours into the game. I played the classic game modes, but I found myself most often playing a custom game mode, specifically one with 30 rows, 24 columns, and 200 mines. Although it hurts to say, I think it took me around 500 tries before I was able to successfully solve one of these boards. The main reason for this being the fact that there are many situations in which you cannot determine with certainty any safe cells. Although I was pretty good at finding safe cells, if those didn't exist, then I was at a loss. After a string of painful losses, I took to the internet in an attempt to improve my skills. What I found was a robust way to calculate the probability of each cell being a mine, given the current state of the board. Although there was a way to do it, the actual computation was extremely intesive, and was nearly impossible to do by hand. However, at the time, I was just getting into programming, and was in the process of taking my first university CS course. I realized that a computer was the perfect tool to calculate these probabilities, and I set out to create a program that would generate these figures for me. Fast forward 3 months, and I had a janky, half-functional Python script, something that at the time I was very proud of. Although it wasn't what I set out to build, at the time I didn't have the skills necessary to build anything much better. Since that introductory class, I found a love for CS, and completely changed trajectories (and majors). Fast forward 2 years, in my last quarter before I graduate with my CS degree, I decided to get around to remastering the project, ultimately resulting in this, minesweeper.v2. In comparison to the previous project, this one runs much faster, determines probabilities exactly, has a frontend, and is deployed on the web. It's been extremely rewarding to see this project come full circle, and I'm so pleased to see how much my software engineering skills have improved over these past 2 years. 

## How to Determine the Probabilities?

At any given point during a Minesweeper game, there is at least one valid board combination (configuration of mines in the board adhering to the rules of the game), given the current state of the board. To determine the probability of a cell, $X_1$, being a mine, you take the total number of valid board combinations with $X_1$ as a mine, divided by the total number of valid board combinations. If there are no valid board combinations that have $X_1$ as a mine, then the probability of the $X_1$ being a mine is 0%; however, if every valid board combination has $X_1$ as a mine, then the probability of $X_1$ being a safe cell is 100%. More often than not, there are some board combinations that are valid with $X_1$ being a mine, and there are some board combinations that are valid with $X_1$ being a safe cell; in this case, given the state of the board, the cell is "undecided," as it could be a safe cell or a mine cell. 

## How Does the Algorithm Work? 

Each clicked cell within the board gives you a rule (axiom) that must be true. These rules contain two critical pieces of information, the number of mines around the cell and the names of the surrounding cells. To illustarte this idea, consider the following board configuration, as well as the rules that are generated by this board: 

1AB2C

DEFGH

Rules: 

[1, {'A', 'D', 'E'}]

[2, {'B', 'C', 'F', 'G', 'H'}]

Ultimately, after my algorithm is ran, JSON will be returned, representing the probability that each cell is a mine. In this case, that JSON object would look like this: {'A': 0.33, 'B': 0.33, 'C': 0.33, 'B': 0.4, 'C': 0.4, 'F': 0.4, 'G': 0.4, 'H': 0.4}. 

Equipped with these rules, we can determine valid board configurations. We do this by generating mine configurations, and then checking to see if they adhere to every rule that has been generated so far. Although this is the general algorithm we use to determine our probabilities, with no optomizations, the world would freeze over before many expert boards could be solved. If you're interested to see this, you can admire my initial Minesweeper repo, which I created ~2 years ago, with next to no programming or software engineering skills. For example, if we simply generated every valid board configuration for an expert board, before the first click, we would have $ùë™(480, 99) \approx 5.60221 \times 10^{104}$ valid board configurations. You can see that checking if each and every one of these combinations adheres to the generated rules is not a sustainable strategy. 

Solving Minesweeper is an NP-hard problem, resulting in every solution out there ultimately running in exponential time. Although there are various optimizations that can and have been implemented, ultimately, the algorithm will fail to keep up with increasing board sizes. Luckily, the classic board setups are relatively small and can therfore be solved quickly. So, now that we know that optimizations can make this problem solvable given the typical Minesweeper board sizes, what are they? 

- Ignoring Informationless Cells: Many cells are "informationless" meaning that none of their adjacent cells that are revealed. In this case, when generating our mine configurations, we leave these cells out. This is because each and every informationless cell will have the same probability of being a mine. Due to this reason, there is no reason to waste computation on generating mine configurations that include these cells. When generating our configurations, we only consider cells next to some revealed cell, as those cells have information, and are therefore worthwhile to compute.
  
- Reducing Rules: Before we get into this optomization, it is important to note that a cell can be "determined" in one of three ways; it can be revealed, it can have a 100% chance of being a mine, or it can have a 0% chance of being a mine. If a cell falls into one of these three categories, then there is no point generating configurations that include this cell as a mine. This is because we already know what the cell is, and therefore there is no information gain associated with including this cell in our configurations. To illustrate this point, consider a rule from before: [2, {'B', 'C', 'F', 'G', 'H'}]. If we knew that 'B' was a mine and we knew that 'C' was safe, then the adjusted rule would be [1, {'F', 'G', 'H'}]. This reduction removes much unecessary computation, allowing our solver to be much more efficient. 

  
- Removing Rules: Some rules are so trivial, that the cells in the rule should not be included in the set of cells that we use when generating configurations. A rule can fall into this category if the number of surrounding cells is equal to the number of mines around the cell, or the number of mines around the cell is 0. In the first case, every cell in the rule is a mine, and in the second case, every single cell in the rule is safe.
  
- Pruning Configurations: When ceating configurations, the large majority of configurations will not adhere to all of the rules in the game. To limit the amount of wasted computation, when generating a configuration, after each cell is added, we will check the rules of the game, and ensure that none of them are violated by this new addition. If we can catch these violations early on, then we can prune the current configuration we were generating, and not have to go through the process of adding all the mines for that configuration. This is due to the fact that if even one rule is violated by a configuration, then it is invalid, and we should not waste time completing the generation of that configuration.
  
- Creating "Islands": When generating mine configurations, it is much more efficient to generate various local configurations than it is to generate one large configuration. This is because if we have two "islands" of information, i.e. groups of cells that are not adjacent to one another, then neither island will provide information about the other. This is because the valid configurations in one part of the board are independent of valid configurations in other parts of the board. Due to this fact, we prefer to generate local configurations instead of global configurations, as we can save lots of time by making only considering the former. If generating configurations for $I_1$ takes A time, and generating configurations for $I_2$ takes B time, the overall time to generate the combinations with local islands is A+B, however with a global configuration, this time explodes up to A*B. Therefore, we work with local configurations instead of global ones. 

## What Technologies Were Used? 
- Frontend: TypeScript, React, Next.js, and Tailwind ‚Äî deployed on Vercel
- Backend: Python and FastAPI ‚Äî deployed on Render

## Any Future Developments? 

Yes, the main thing that I'd like to add to the solver is a better algorithm for determining which cell the solver chooses, when equipped with the probabilities. Right now, the solver simply clicks the cell that has the lowest probability of being a mine; although this is a very good heuristic, it is not necessarily the optimal choice. You can imagine situations where taking on a bit more risk in the short term results in a higher probability of solving the overall board. As far as implementing this goes, I'm at a bit of a loss; I plan to discuss this problem with some of my professors, and hopefully they can point me in the right direction. If anyone reading this has any ideas, feel free to reach out! 
